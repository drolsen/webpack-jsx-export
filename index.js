const fs = require('fs');
const glob = require('glob');
const path = require('path');
const { parse } = require('node-html-parser');
const ReactDOM = require('react-dom/server');
const pretty = require('pretty');
const merge = require('merge-deep');

const QuotesPlugin = require('./plugins/symbols.plugin.js');
const SymbolsPlugin = require('./plugins/symbols.plugin.js');

class WebpackJSXExport {
  constructor(options) {
    this.defaultFilter = (file) => { return file; }
    this.defaultExtension = (file) => {
      file.extension = '.html';
      return file;
    };

    this.defaultComment = (file) => { 
      file.comment = 'THIS FILE IS AUTO GENERATED BY WebpackJSXExport'; 
      return file; 
    };

    this.options = merge({
      files: [],
      plugins: {
        input: [],
        output: [
          QuotesPlugin,
          SymbolsPlugin
        ],
      },
      globals: {},
      templates: (file) => { return file; },
      warnings: true
    }, options);

    this.originalError = console.error.bind(console.error);

    if (this.options.warnings === false) {
      console.error = (msg) => {
        if (msg.toString().indexOf('Warning: React') !== -1) { return false; }
      };      
    }   
  }

  // Helper method to register babel plugins for JSX collecting
  babelRegister(compiler = false) {
    // Registering required dependencies to both parse and import JSX files directly into NodeJS
    // .JSX imports must happen after this register, or else I'll come to your house and break all your spaghetti!
    require("@babel/register")({
      ignore: [],
      presets: ['@babel/preset-env', 
        [
          '@babel/preset-react',
          {
            'development': false
          }
        ]
      ],  
      plugins: [
        [
          require.resolve('babel-plugin-import-globals'), {   // (see: https://www.npmjs.com/package/babel-plugin-import-globals)
            "React": "react",
            "PropTypes": 'prop-types'
          }
        ], [
          require.resolve('babel-plugin-module-resolver'), {  // (see: https://www.npmjs.com/package/babel-plugin-module-resolver)
            'alias': (compiler) ? compiler.options.resolve.alias : {}
          }
        ], 
        this.options.plugins.length 
          ? (this.options.plugins.input.length)
            ? this.options.plugins.input : {}
          : {},
        'babel-plugin-file-loader',                           // (see: https://www.npmjs.com/package/babel-plugin-file-loader)
        'babel-plugin-transform-require-context',             // (see: https://www.npmjs.com/package/babel-plugin-transform-require-context)
        '@babel/plugin-transform-react-jsx',                  // (see: https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)
        '@babel/plugin-transform-object-rest-spread',          // (see: https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread)
        '@babel/plugin-transform-class-properties',            // (see: https://babeljs.io/docs/en/babel-plugin-transform-class-properties/)
        '@babel/plugin-transform-react-display-name',         // (see: https://www.npmjs.com/package/babel-plugin-add-react-displayname)
        '@babel/plugin-transform-nullish-coalescing-operator', // (see: https://babeljs.io/docs/en/babel-plugin-transform-nullish-coalescing-operator)
        '@babel/plugin-transform-async-generator-functions',   // (see: https://babeljs.io/docs/en/babel-plugin-transform-async-generator-functions)
        '@babel/plugin-transform-for-of',                     // (see: https://babeljs.io/docs/en/babel-plugin-transform-for-of)
        '@babel/plugin-transform-optional-chaining',           // (see: https://babeljs.io/docs/en/babel-plugin-transform-optional-chaining)
        '@babel/plugin-transform-reserved-words'              // (see: https://babeljs.io/docs/en/babel-plugin-transform-reserved-words)
      ]
    });

    // Now that our babel is registered, we can hoist up globals
    if (this.options.globals) {
      Object.keys(this.options.globals).map((i) => {
        // Some globals are not trying to be required files, but are variables for string data
        if (typeof this.options.globals[i] === 'string') {
          global[i] = require(this.options.globals[i]);
        }
      });
    }
  }

  // Helper method to collect JSX files
  collect(files) {
    const collection = [];

    // Because we are using NodeJS and not Webpack, we don't have webpack's powerful import wildcard capabilities so
    // we use glob lib instead to collect all example.jsx files
    Object.keys(files).map((i) => {
      let { output } = files[i];
      let extension = (typeof files[i].extension !== 'undefined') ? files[i].extension : this.defaultExtension;
      const { input } = files[i];
      const filter = (files[i].filter) ? files[i].filter : this.defaultFilter;

      const comment = (typeof this.options.comment !== 'undefined') 
        ? this.options.comment 
        : this.defaultComment;

      // Glob gather (reguardless if its a direct path to JSX file)
      glob.sync(input.replaceAll(path.sep, path.posix.sep)).forEach((file) => {
        // Only .jsx files please
        if (path.basename(file).indexOf('.jsx') !== -1) {
          // Build up our file information object for export processing
          let fileInfo = {
            comment,
            extension,
            name: path.basename(path.resolve(__dirname, file)),
            output,
            source: require(path.resolve(__dirname, file))
          };

          // Scrub our file information against filtering
          if (filter(fileInfo)) {
            // Scrub our file information against comments
            if (typeof comment === 'function') {
              fileInfo = comment(fileInfo);
            }

            // If extension happens to be function, we pass file information through it
            if (typeof extension === 'function') {
              fileInfo = extension(fileInfo);
            }

            // Ensure extension passed in file.input is used instead of options.extension
            if (!Array.isArray(fileInfo.output)) {
              if (path.extname(fileInfo.output) === fileInfo.extension) {
                fileInfo.output = fileInfo.output.replace(
                  new RegExp(`\\${fileInfo.extension}`),
                  ''
                );
              }
            } else {
              Object.keys(fileInfo.output).map((j) => {
                if (path.extname(fileInfo.output[j]) === fileInfo.extension) {
                  fileInfo.output[j] = fileInfo.output[j].replace(
                    new RegExp(`\\${fileInfo.extension}`),
                    ''
                  );
                }
              });
            }

            // Finally we collect file information
            collection[file] = fileInfo;            
          }          
        }
      });
    });
    
    return collection;
  }

  // Helper method to process collected JSX files
  process(collection) {
    // Once we have a full collection, lets loop over it and begin rendering
    Object.keys(collection).map((i, index) => {
      let { source } = collection[i];
      let { output } = collection[i];
      const { comment } = collection[i];
      const { extension } = collection[i];
      if (!Array.isArray(output)) {
        const isFolder = !path.extname(output) && output.charAt(output.length-1) === '/';
        // If the file has source only
        if (source) {
          // Output path is FOLDER (aka we want to reuse input filename for export)
          if (isFolder) {
            // If folder does not exist lets make it
            if (!fs.existsSync(path.resolve(__dirname, `${output}`))) {
              fs.mkdirSync(path.resolve(__dirname, `${output}`),  { recursive: true });
            }

            // Requested path + input JSX filename + input JSX file extension
            output = path.resolve(__dirname, `${output}/${path.basename(i)}`);
          }

          // Output path is FILE (aka we are requesting a custom filename for export)
          if (!isFolder){
            // Getting parent folder of output file path
            const _output = path.resolve(
              __dirname,
              `${output.replace(new RegExp(path.basename(output)), '')}`
            );

            // If parent folder does not exist lets make it
            if (!fs.existsSync(_output)) {
              fs.mkdirSync(_output,  { recursive: true });
            }

            // Requested path + input JSX file extension (input JSX file extension used as placeholder)
            output = path.resolve(__dirname, `${output}${path.extname(i)}`);
            output = output.replace(new RegExp(path.basename(output)), path.basename(output));
          }



          // Pass file information to write (note that output replaces .extension with requested .extension).
          this.write({
            source,
            comment,
            index,
            name: path.basename(output),
            path: output.replace(new RegExp(`\\${path.extname(output)}`, 'g'), extension)
          });
        }
      } else {
        let isFolder = false;
        Object.keys(output).map((j) => {
          if (!path.extname(output[j]) && output[j].charAt(output[j].length-1) === '/') {
            isFolder = true;
          }
        });

        Object.keys(source).map((j) => {
          // If the file has source only
          if (source[j]) {
            // Output path is FOLDER (aka we want to reuse input filename for export)
            if (isFolder) {
              // If folder does not exist lets make it
              if (!fs.existsSync(path.resolve(__dirname, `${output[j]}`))) {
                fs.mkdirSync(path.resolve(__dirname, `${output[j]}`),  { recursive: true });
              }

              // Requested path + input JSX filename + input JSX file extension
              output[j] = path.resolve(__dirname, `${output[j]}/${path.basename(i)}`);
            }

            // Output path is FILE (aka we are requesting a custom filename for export)
            if (!isFolder){
              // Getting parent folder of output file path
              const _output = path.resolve(
                __dirname,
                `${output[j].replace(new RegExp(path.basename(output[j])), '')}`
              );

              // If parent folder does not exist lets make it
              if (!fs.existsSync(_output)) {
                fs.mkdirSync(_output,  { recursive: true });
              }

              // Requested path + input JSX file extension (input JSX file extension used as placeholder)
              output[j] = path.resolve(__dirname, `${output[j]}${path.extname(i)}`);
              output[j] = output[j].replace(new RegExp(path.basename(output[j])), path.basename(output[j]));
            }

            // Pass file information to write (note that output replaces .extension with requested .extension).
            this.write({
              source: source[j],
              comment: comment[j],
              j,
              name: path.basename(output[j]),
              path: output[j].replace(new RegExp(`\\${path.extname(output[j])}`, 'g'), extension)
            });
          }
        });
      }
    });
  }

  // Helper method that is used procure JSX into Markup and write to disk
  write(fileInfo) {
    // Process plugin PreParse hooks
    try {
      Object.keys(this.options.plugins.output).map((i) => {
        const plugin = this.options.plugins.output[i]().PreParse;

        if (plugin) {
          if (plugin(fileInfo)) {
            fileInfo = plugin(fileInfo);
          }
        }
      });     
    } catch (err) { console.error(err); }

    let DOM = parse(ReactDOM.renderToStaticMarkup(fileInfo.source.default));

    // Remove any elements flagged to NOT be rendered in production views
    if (DOM.querySelector('no-export')) {
      const nonExportingFragments = DOM.querySelectorAll('no-export');
      let nodeLength = nonExportingFragments.length;
      while (nodeLength--) {
        Object.defineProperty(nonExportingFragments[nodeLength], 'tagName', { value: '' });
        Object.defineProperty(nonExportingFragments[nodeLength], 'rawTagName', { value: '' });
        Object.defineProperty(nonExportingFragments[nodeLength], 'childNodes', { value: [] });
      }
    }

    if (DOM.querySelector('export')) {
      const exportingFragments = DOM.querySelectorAll('export');
      let nodeLength = exportingFragments.length;
      while (nodeLength--) {
        Object.defineProperty(exportingFragments[nodeLength], 'tagName', { value: '' });
        Object.defineProperty(exportingFragments[nodeLength], 'rawTagName', { value: '' });
      }
    }

    // Process plugin PostParse hooks
    try {
      Object.keys(this.options.plugins.output).map((i) => {
        const plugin = this.options.plugins.output[i]().PostParse;

        if (plugin) {
          if (plugin(DOM)) {
            DOM = plugin(DOM);
          }
        }
      });      
    } catch (err) { console.error(err); }

    // Make pretty and write processed export to disk
    fs.writeFile(
      fileInfo.path,
      pretty(
        `
          ${
            (fileInfo.comment) 
              ? `<!--/* ${ fileInfo.comment } */-->` 
              : ''
          }
          ${DOM.toString()}
        `
      ),
      (e) => {
        if (e) {
          console.error(e);
          return false;
        }
      }
    );

    console.error = this.originalError;
  }

  apply(compiler) {
    compiler.hooks.done.tap({ name: 'WebpackJSXExport' }, () => {
      this.babelRegister(compiler);
      const collection = this.collect(this.options.files);
      this.process(collection);
    });
  }

  run() {        
    this.babelRegister();
    const collection = this.collect(this.options.files);
    this.process(collection);
  }
}

module.exports = WebpackJSXExport;
